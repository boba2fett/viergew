	\documentclass[12pt,a4paper]{article}
	\addtolength{\footskip}{-1cm}
	\usepackage[a4paper, left=3.5cm, right=2cm, top=2.5cm, bottom=1.2cm]{geometry}
	\usepackage[utf8]{inputenc}
	\usepackage[onehalfspacing]{setspace}
	\usepackage{mathptmx}
	\usepackage[T1]{fontenc}
	\usepackage[ngerman]{babel}
	\usepackage{graphicx} 
	\usepackage{hyperref} 
	\usepackage{pgfplots}
	\usepackage{listings}
	\lstset{numbers=left, numberstyle=\tiny, numbersep=5pt}
	\lstset{language=Java}
	%\usepackage[german]{algorithm2e}
	%\glqq\grqq{}
	\usepackage{tikz}
	\usetikzlibrary{positioning,shadows,arrows}

	\title{Vier Gewinnt}
	\author{Florian Tünte}
	%
	
	\usepackage[onehalfspacing]{setspace}
	\def\code#1{\texttt{#1}}
	\begin{document}
	
	\pagenumbering{gobble}
	
	\begin{figure}[htbp]
		
		\begin{minipage}[t]{3cm}
			
			\vspace{0pt}
			
			\flushleft
			
			\includegraphics[width=3cm, height=3cm]{LogoGymnasiumMariengarden}
			
			\label{fig:LogoGymnasiumMariengarden}
			
		\end{minipage}
		
		\hfill
		
		\begin{minipage}[t]{6cm}
			
			\vspace{0pt}
			
			\flushleft
			
			{\Large Gymnasium Mariengarden}
			
		\end{minipage}
		
	\end{figure}
	
	\begin{flushright}
		
		\large{Florian Tünte}
		
	\end{flushright}
	
	
	\begin{center}
		
		\vspace{30pt}
		
		{\LARGE Facharbeit}\\
		
		\vspace{50pt}
		
		\textbf{{\Huge Vier Gewinnt}}\\
		
		{\large Entwicklung einer künstlichen Intelligenz am Beispiel Vier Gewinnt mit der Programmiersprache java
\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth, height=0.2\textheight]{Viergewinnt}
	\label{fig:viergewinnt}
\end{figure}
			
		}
		
		\vspace{90pt}
		
		{\large Kurs: Informatik Grundkurs\\
			
			Fachlehrer: Herr Stroick\\
			
			Datum der Themenausgabe: 01.03.2019\\
			
			Die Arbeit wurde abgegeben am 14.05.2019\\}
		
		\vspace{20pt}
		
		\textbf{{\large Die vorliegende Arbeit erhält die Note:}}
		
	\end{center}
	
	\pagebreak
	\tableofcontents
	\newpage
	\pagenumbering{arabic}
	\setcounter{page}{2}
	\section{Einleitung}
	Das Spiel Vier Gewinnt erscheint auf den ersten Blick relativ simpel und ist ein Spieleklassiker. Nahezu jeder hatte schon Kontakt mit diesem Spiel und hat es sicher einmal oder auch viele Male gespielt. Egal ob auf einem Blatt Papier im Unterricht, mit kleineren oder größeren Spielen aus Plastik, es ist immer ein faszinierendes Spiel für zwei Personen. Das Problem beim klassischen Brettspiel ist, dass die Spielsteine immer wieder verloren gehen oder sogar im Staubsauger landen. Außerdem muss ein Spielpartner vorhanden sein. Die Digitalisierung des Spiels bringt vielfältige weitere Möglichkeiten das Spiel zu erweitern mit sich oder auch für Menschen mit Handicap zugänglich zu machen.\\ Es ist nicht so simpel wie z.B. Tic-Tac-Toe, bei dem es unter geübten Spielern immer in einem Unentschieden endet. Bei dem Spiel Vier Gewinnt geht es im Wesentlichen um das Aufbauen von Fallen, die man dann ausnutzen kann, um zu gewinnen, wenn der Gegenspieler diese ausgelöst hat. Nachdem ich schon einmal ein Tic-Tac-Toe Spiel mit unbesiegbarem Computergegner programmiert hatte.
	%auf der Suche nach einem anspruchsvollerem Spiel; die Wahl fiel auf Vier gewinnt 
	\footnote{https://github.com/boba2fett/TicTacToe}
	, war mir klar, dass ich bei der Facharbeit dies mit einem  Vier Gewinnt Spiel umsetzen könnte. Zunächst werde ich das Spiel erläutern und die Implementation des Hauptspiels. Danach auf die Funktion der KI in diesem Zusammenhang. Anschließend auf KI generell. Ein Großteil der Arbeit liegt unter anderem auch in der Programmierung des Spiels sowie der KI.
	\section{Vier Gewinnt}
	Im folgenden Abschnitt gehe ich auf das Vier Gewinnt Spiel näher ein. Danach geht es um die Implementation bzw. Programmierung des Vier Gewinnt Spiels und abschließend darum, wie das Programm zu starten ist und welche Voraussetzungen dafür gegeben sein müssen.
	\subsection{Spielidee}
	Die Grundidee des Vier Gewinnt Spieles ist es, vier der eigenen Spielsteine bzw. Symbole in eine Reihe zu bringen.
	Dabei ist es egal, ob dies horizontal, vertikal oder diagonal erreicht wird.
	Es spielen immer zwei Spieler gegeneinander, die abwechselnd einen Spielstein von oben in das Spielfeld einfügen, der dann so lange herunterfällt, bis er auf das Ende des Spielfeldes oder einen anderen Spielstein stößt.
	%einwerfen, herabfallen, setzen
	Sobald zum ersten Mal vier Spielsteine eines Spielers eine Reihe bilden, endet das Spiel und der betreffende Spieler gewinnt.
	Das Spielfeld in der Grundversion ist ein Spielfeld aus 7 senkrechten Spalten und 6 waagerechten Zeilen. Grundsätzlich sind aber auch größere und kleinere Spielfelder möglich 
	(Lehmann, Jörg \glqq Vier gewinnt\grqq{} http://www.brettspiele-report.de/vier-gewinnt/ Stand: 01.05.2019).
	\subsection{Implementation}
	Zu Beginn habe ich ein Github-Repository angelegt und das Grundspiel Vier Gewinnt programmiert.\footnote{https://github.com/boba2fett/viergew} Das Wichtigste dabei war zu erkennen, dass jemand gewonnen hat und zudem die Möglichkeit mit zwei Spielern abwechselnd in die verschiedenen Spalten zu setzen.
	Nach der Umsetzung des kompletten Projekts versuchte ich die Laufzeit etwas zu senken, indem ich eine eigene Klasse \code{VierLogik} erstellte, an deren Objekten die Simulationen durchgeführt wird, um es mehr abzutrennen und die redundante Speicherung der bisherigen Züge zu vermeiden. Am Ende des Entwicklungsprozesses habe ich eine grafische Oberfläche erstellt, um das Spiel effizienter zu testen bzw., um es ansprechender zu machen. Dabei fiel mir auf, dass die Funktion zu sehen, mit welchen Feldern man gewonnen hat, sehr praktisch ist, da ansonsten der Überblick und die Lust am Spielen verloren geht. In der Konsolen-Version waren die Tester nur wenig begeistert.
	Damit sieht das Implementationsdiagramm ohne die Klasse, die für die KI zuständig ist, wie folgt aus:
\begin{figure}[h]
	\centering
	\label{Impementationsdiagramm}
	\includegraphics[width=0.7\linewidth, height=0.4\textheight]{maybe/Klassendiagramme}
	\caption{Implementationsdiagramme}
	\label{fig:klassendiagramme}
\end{figure}
\newpage
	\subsection{Das Programm}
	Wie startet man das Programm? Wenn java installiert ist, sollte ein Doppelklick auf die jar-Datei genügen. Andernfalls muss java noch installiert werden.\footnote{https://www.java.com/de/download/manual.jsp \space{} Empfohlen: java 8} Die jar-Datei ist direkt im \code{viergew} Verzeichnis zu finden. Die grafische Oberfläche öffnet sich und man hat die Gelegenheit sich für eine Spielfeldgröße zu entscheiden. Danach muss man auswählen, ob der Computer die Rolle des Anfangenden übernimmt oder nicht, oder ob man lieber zu zweit spielt.\\
	\section{Die KI (künstliche Intelligenz) des Vier Gewinnt Spiels}
	Dieser Abschnitt befasst sich mit der hier implementierten KI, sowie dem Minimax-Algorithmus, der ihr zugrunde liegt. Es wird anhand von Beispielen erläutert. Ebenso gibt es Ausführungen über die Effizienz und die Schwächen der KI.\\
	\subsection{Taktik der KI}
	Die Taktik der KI ist zu gewinnen oder eine (unmittelbare) Niederlage zu verhindern. Dazu wird ein Minimax-Algorithmus genutzt, um die beste Entscheidung zu treffen. Bei diesem Verfahren durchläuft der Algorithmus einen Suchbaum, der bei der maximalen Suchtiefe jedem Ergebnis einen Wert zuweist oder, wenn schon vorher ein Sieg oder eine Niederlage auftritt, diesen jeweils einen positiven bzw. negativen Wert zuordnet. Bei der Auswertung wird dann immer das Minimum der gegnerischen Züge gewertet und das Maximum der eigenen, so dass jeder Spieler ein \glqq perfektes\grqq{} Spiel spielt. Des Weiteren bevorzugt der Algorithmus einen schnellen Sieg bzw. eine späte Niederlage.\\
	Neben dem Minimax-Algorithmus könnten auch vorberechnete Eröffnungszüge genutzt werden, diese unterscheiden sich jedoch für jede Spielfeldgröße. Einige Spiele gelten dadurch auch schon als gelöst.\\
	Das Diagramm zeigt wer bei einem perfekten Spiel gewinnt (+ der anfangende Spieler gewinnt, - der Gegenspieler gewinnt, = Unentschieden), wenn man die Höhe und Breite variiert.\\\\ Bei dem Grundspiel 7x6 ergibt sich, dass bei einem perfekten Spiel beider Spieler immer der anfangende Spieler gewinnen würde (height:6, width:7).\\
	Bei einem 8x8 Spielfeld sähe die Sache anders aus, hier gewinnt der zweite Spieler (height:8, width:8).
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.5\linewidth, height=0.3\textheight]{w-h-viergew}
		\caption{Feldgrößen und wer gewinnt}
		\label{fig:w-h-viergew}
		(Tromp, John  \glqq John's Connect Four Playground\grqq{} http://tromp.github.io/c4/c4.html Stand: 01.05.2019)
	\end{figure}
	\\\\\\
	\subsection{Schwächen}
	Theoretisch sind der KI mit dem Minimax-Algorithmus nur Grenzen durch die Rechenleistung des Computers bzw. die Tiefe der Simulation gesetzt.
	
	\subsection{Implementation}
	Zunächst auch zu dieser Klasse das Implementationsdiagramm.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth, height=0.3\textheight]{maybe/KlassendiagrammKI}
	\caption{Implementationsdiagramm der Klasse AiMiniMax}
	\label{fig:klassendiagrammki}
\end{figure}\\\\\\
	Die wichtigste Frage ist zunächst, wie der Computer \glqq denken\grqq{} soll. Als ich im Internet recherchiert habe, stieß ich auf den Minimax-Algorithmus. Die Grundidee ist, dass jeder Spieler ein  \glqq perfektes\grqq{} Spiel spielt (Wikimedia Foundation Inc. \glqq Minimax\grqq{} https://en.wikipedia.org/wiki/Minimax Stand: 12.05.2019). Hier verwendet ist aber eine Abgewandelte Form, da manche Pfade nicht weiter verfolgt werden, wenn sie nicht in das Ergebnis einfließen. Für die Implementation habe ich mich dann am Wikipedia Pseudocode orientiert. Das Interessante ist, dass ich zuerst auf den englischen Artikel gestoßen bin und, dass sich der Pseudocode deutlich unterscheidet (Wikimedia Foundation Inc. \glqq Minimax\grqq{} https://en.wikipedia.org/wiki/Minimax Stand: 12.05.2019).\\
		Die KI ist in der Klasse \code{AiMiniMax} beherbergt. Hier die wichtigen Zeilen des Quelltextes:\\\\
		\code{Listing 1:}
		\begin{lstlisting}
int aiTurn(){
for(int j=0;j<w;j++){
 if(recreate(j).checkwinner()!=-1){return j;}
 use[j]=legal(j);
 if(use[j]){
  ArrayList<Integer> hist=new ArrayList<Integer>();
  hist.add(j);
  eval[j]=minimax(false,hist,deepness);
 }
}
for(int j=0;j<w;j++){
 if(use[j]&&eval[j]==i){
  whynot.add(j);
 }
}
if(whynot.size()!=0){
 int num = (int)(Math.random() * whynot.size());
 return whynot.get(num);
}
}
\end{lstlisting}
Die dabei wichtigen Methoden sind zum einen die Methoden zum Erzeugen von \code{VierLogik} Objekten, an denen die Simulationen durchgeführt werden, zum anderen die Umsetzung des MiniMax-Algorithmus. Der Aufruf aus \code{VierGame} benutzt die Methode \code{aiTurn}. In dieser Methode wird jeder Möglichkeit auf ein Feld zu setzen ein Wert durch den MiniMax-Algorithmus zugeordnet (Zeile 8). Danach wird von oben herab ein Wert gesucht, bis die höchsten Werte gefunden sind bzw. der höchste Wert (Zeile 12). Aus diesen wird dann zufällig einer Ausgewählt (Zeile 16-18), da die Werte für die Entscheidungen, die damit verknüpft sind, gleichwertig sind. Aber nun kümmern wir uns um die \code{minimax} Methode:\\
\code{Listing 2:}
\begin{lstlisting}
private int minimax(boolean maximizingPlayer, 
ArrayList<Integer> hist,int depth){
if(depth==0){return 0;}
int value;
VierLogik test;
if(maximizingPlayer){
 value = -deepness-1;
 for(int i=0;i<w;i++){
  test=recreate(hist);
  if(test.setOn(i)){
   if(test.checkwinner()==-1){
    if(depth-1==0){value = Math.min(value, 0);}
    else{
     ArrayList<Integer> hist2 = (ArrayList<Integer>) hist.clone();
     hist2.add(i);
     value = Math.max(value, minimax(false, hist2, depth - 1));
    }
   }
   if(test.checkwinner()==0){value = Math.max(value, 0);}
   if(test.checkwinner()==sp){return depth;}
  }
 }
}
else{
 value = deepness+1;
 for(int i=0;i<w;i++){
  test=recreate(hist);
  if(test.setOn(i)){
   if(test.checkwinner()==-1){
     ArrayList<Integer> hist2 = (ArrayList<Integer>) hist.clone();
     hist2.add(i);
     value = Math.min(value, minimax(true, hist2, depth - 1));
   }
   if(test.checkwinner()==0){value = Math.min(value, 0);}
   if(test.checkwinner()==gsp){return -depth;}
  }
 }
}
return value;
}
		\end{lstlisting}
	Der Aufruf erfolgt damit, dass der Zug günstig für den Gegenspieler ist (minimierend für die KI | \code{maximizing=false}), weil der Zug der KI ja schon für jedes der verfügbaren Felder gemacht wurde und in \code{hist} bereits enthalten ist, um jedem dieser Felder mit dem Aufruf von \code{minimax(false,hist,deepness);}(Zeile 8, Listing 1) einen Wert zuzuweisen. Wenn es hier, bei einer der durchprobierten Möglichkeiten für den Gegenspieler zu setzen, zu einem Sieg des Gegenspielers kommt, wird ein negativer Wert, der \code{depth} entspricht zurückgegeben (Zeile 35). Dies sorgt dafür, dass eine spätere Niederlage besser bewertet wird als eine frühe Niederlage. Bei einem Unentschieden ist der entsprechende Wert 0 (Zeile 34). Wenn nichts davon eingetreten ist, wird der entsprechende Zug in \code{history} gespeichert und der Algorithmus beginnt den nächsten Zug des Spielers zu bewerten. Hier gilt das Umgekehrte, da es den Spieler maximiert. Ein früher Sieg bekommt eine sehr positive Bewertung und im nächsten Aufruf ist es wieder minimierend. Wenn die maximale Suchtiefe erreicht ist, wird 0 zurückgegeben und diese Reihenfolge an Zügen wird wie ein Unentschieden behandelt (Zeile 3).
	\subsubsection{Erstes Beispiel}
	Nun betrachten wir eine Beispielsituation, wie sie vorkommen könnte und sehen uns genauer an, wie die KI ihre Entscheidung trifft. Diese wirde durchgeführt auf einem kleinen Feld von der Größe 4x4, darauf soll die KI einen Verteidigungszug machen. Damit das Log nicht zu lang wird, wird die KI auf eine Suchtiefe von 4 begrenzt. Die Ausgaben werden erzeugt durch die Klasse \code{AiMiniMaxPrint}(\code{AiMiniMax} ergänzt um Konsolen-ausgabe).
	Gegeben ist folgende Situation (folgendes sind Screenshots aus dem Programm):
\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth, height=0.4\textheight]{maybe/fach0}
	\caption{Anfangssituation}
	\label{fig:fach0}
\end{figure}
	\\Im folgenden setzt der Spieler beispielsweise gegen den Computer auf das Feld 3:1, um zu testen, ob er die Bedrohung erkennt.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth, height=0.4\textheight]{maybe/fach1}
	\caption{KI erkennt die Bedrohung}
	\label{fig:fach1}
\end{figure}
	\\Das Ergebnis: Der Computer erkennt die Bedrohung. Aber warum?\\
	Dazu sehen wir uns das generierte Log an. Zu finden unter \code{/viergew/FachTex/maybe/fach0-1}.\\\\\\
	\code{Listing 3}
	\begin{lstlisting}[basicstyle=\sffamily]
0,3 Defeat
1,3 Defeat
2,3 Defeat
3,return 0
Evaluated Value 0
Consider 3
	\end{lstlisting}
	Aber was steht hier? Es werden alle Möglichkeiten durchprobiert, bis man in einer maximierenden Ebene auf einen Sieg oder in einer minimierenden Ebene auf eine Niederlage trifft. Zeile 1 zeigt, wenn der Computer auf 0 setzt, dass der Spieler mit dem Setzen auf 3 gewinnt. Also eine Niederlage für die KI. Zeile 2 und 3 zeigen das gleiche Ergebnis für den ersten Zug auf 2 oder 3. Zeile 4 hingegen macht deutlich, dass in den weiteren Stufen bis zur maximalen Suchtiefe weder der Spieler noch die KI durch ein perfektes Spiel gewinnt.
	\\
	\begin{figure}[h]
		\centering
		\label{fig:baumdiagramm1}
	\begin{tikzpicture}[
	max/.style={rectangle, draw=none, rounded corners=1mm, fill=blue, drop shadow,
		text centered, anchor=north, text=white},
	min/.style={circle, draw=none, fill=orange, circular drop shadow,
		text centered, anchor=north, text=white},
	beginn/.style={circle, draw=none, fill=red, circular drop shadow,
		text centered, anchor=north, text=white},
	level distance=0.5cm, growth parent anchor=south
	]
	\node (n) [max,sibling distance=9cm] {Anfang}
child{
	[sibling distance=5cm]
	node (c) [max] {0}
	child{
		[sibling distance=1.7cm]
		node (c1) [min] {1}
		child{[sibling distance=0.5cm]
			node (c11) [max] {1}
			child{
				node (c111) [min] {1}
			}
			child{
				node (c112) [min] {2}
			}
			child{
				node (c113) [min] {3}
				child{
					node (c113D) [min] {D}
				}
			}
		}
		child{[sibling distance=0.5cm]
			node (c12) [max] {2}
			child{
				node (c121) [min] {1}
			}
			child{
				node (c122) [min] {2}
			}
			child{
				node (c123) [min] {3}
				child{
					node (c123D) [min] {D}
				}
			}
		}
		child{[sibling distance=0.5cm]
			node (c13) [max] {3}
			child{
				node (c131) [min] {1}
			}
			child{
				node (c132) [min] {2}
			}
		}
	}
	child{
		[sibling distance=1.7cm]
		node (c2) [min] {2}
		child{[sibling distance=0.5cm]
			node (c21) [max] {1}
			child{
				node (c211) [min] {1}
			}
			child{
				node (c212) [min] {2}
			}
			child{
				node (c213) [min] {3}
				child{
					node (c113D) [min] {D}
				}
			}
		}
		child{[sibling distance=0.5cm]
			node (c12) [max] {2}
			child{
				node (c221) [min] {1}
			}
			child{
				node (c222) [min] {2}
			}
			child{
				node (c223) [min] {3}
				child{
					node (c123D) [min] {D}
				}
			}
		}
		child{[sibling distance=0.5cm]
			node (c23) [max] {3}
			child{
				node (c231) [min] {1}
			}
			child{
				node (c232) [min] {2}
			}
		}
	}
	child{
		node (c3) [min] {3}
		child{
			node (c3d) [min] {D}
		}
	}
}
	;
	\end{tikzpicture}
	\caption{Baumdiagramm zur Entscheidung auf 0 zu setzen}
	\end{figure}
	\\\\
	Hier ist das Baumdiagramm zu 0 als ersten Zug der KI zu sehen, in dem alle Simulationen angeführt sind, die gemacht werden. Endet ein Pfad im Nichts, ist die maximale Tiefe erreicht, also im Ergebnis ein Unentschieden. Steht ein D am Ende eines Pfades ist es eine Niederlage. Viereckige (blaue) Knoten sind Maximierende und runde (orange) Minimierende. Das heißt, dass bei Viereckigen Knoten immer das Maximum des Kontens und seiner Geschwister an den darüber liegenden Konten weitergereicht wird und dass bei den runden Knoten immer das Minimum des Kontens und seiner Geschwister an den darüber liegenden Konten weitergereicht wird. Beginnen wir von links mit der Auswertung des Baumdiagrammes an.\\ Die maximale Tiefe ist erreicht, also ist der Wert für den Pfad 0-1-1 (von oben nach unten gelesen) erst mal das Maximum 0. Der nächste Wert von links ist wieder 0, also keine Veränderung. Das darauf folgende Ergebnis ist eine Niederlage und da es ein minimierender Knoten ist, zählt hier das Minimum der Niederlage. Der Knoten 0-1-2 liefert kein anderes Ergebnis. Der Knoten 0-1-3 hingegen liefert 0. Dadurch wird der Wert des maximierenden Knotens 0-1 auch 0. Für den Knoten 0-2 gilt das gleiche. Der Knoten 0-3 mündet direkt in eine Niederlage und damit einen negativen Wert (hier -2, da $Wert = - Suchtiefe + aktuelle Tiefe$). Das Minimum von 0-1, 0-2 und 0-3 ist also -2.\\
	Bei dem Start mit dem Knoten 3 ergibt sich nachher ein Wert von 0, der dann den anderen Ergebnissen (0,1,2) bevorzugt wird. Am Ende wird im Log noch niedergeschrieben, dass beim Wert 0 das Feld 3 eine Möglichkeit ist (\code{Evaluated Value 0} und \code{Consider 3}), welches dann auch ausgewählt wird.
	\newpage
	\subsubsection{Zweites Beispiel}
	Beim zweiten Beispiel wird nun eine Situation herbeigeführt, bei dem wir bei dem Spiel in der Zwickmühle sitzen.
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.4\linewidth, height=0.3\textheight]{maybe/fach2}
		\caption{Anfangssituation}
		\label{fig:fach2}
	\end{figure}
	\\Nun setzen wir als Spieler auf 2:0, um nicht das Spiel zu verlieren.
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.4\linewidth, height=0.3\textheight]{maybe/fach3}
		\caption{KI trifft gute Entscheidung}
		\label{fig:fach3}
	\end{figure}\\
	Die KI setzt auf 3:1 und wir haben keine Chance mehr zu gewinnen. Setzen wir auf 4:1, setzt die KI im nächsten Zug auf 4:0 und gewinnt. Setzten wir hingegen nicht auf 4:1, setzt die KI auf dieses Feld und gewinnt ebenfalls.
	Schauen wir uns nun wieder den Suchbaum an, er geht hervor aus \code{/viergew/FachTex/maybe/fach2-3}.\\
	\newpage
	\begin{figure}[h]
	\centering
	\label{fig:baumdiagramm2}
	\begin{tikzpicture}[
	max/.style={rectangle, draw=none, rounded corners=1mm, fill=blue, drop shadow,
		text centered, anchor=north, text=white},
	min/.style={circle, draw=none, fill=orange, circular drop shadow,
		text centered, anchor=north, text=white},
	beginn/.style={circle, draw=none, fill=red, circular drop shadow,
		text centered, anchor=north, text=white},
	level distance=0.5cm, growth parent anchor=south
	]
	\node (n) [max,sibling distance=9cm] {Anfang}
	child{
		[sibling distance=5cm]
		node (c) [max] {3}
		child{
			[sibling distance=1.7cm]
			node (c1) [min] {1}
			child{[sibling distance=0.5cm]
				node (c13) [max] {3}
				child{
					node (c134) [min] {4}
					child{
						node (c1344) [max] {4}
						child{
							node (c1344W) [max] {W}
						}
					}
				}
			}
			child{[sibling distance=0.5cm]
				node (c14) [max] {4}
				child{
					node (c14W) [max]{W}
				}
			}
		}
		child{
			[sibling distance=1.7cm]
			node (c3) [min] {3}
			child{[sibling distance=0.5cm]
				node (c31) [max] {1}
				child{
					node (c314) [min] {4}
					child{
						node (c3144) [max] {4}
						child{
							node (c3144W) [max] {W}
						}
					}
				}
			}
		child{[sibling distance=0.5cm]
			node (c34) [max] {4}
			child{[sibling distance=0.5cm]
				node (c34W) [max] {W}
			}
		}
		}
		child{[sibling distance=2cm]
			node (c4) [min] {4}
			child{[sibling distance=1cm]
				node (c41) [max] {1}
				child{
					node (c413) [min] {3}
					child{
						node (c4134) [max] {4}
						child{
							node (c4134W) [max] {W}
						}
					}
				child{
					node (c4143) [max] {3}
					child{
						node (c4143T) [max] {T}
					}
				}
				}
			}
		child{[sibling distance=1cm]
			node (c43) [max] {3}
			child{
				node (c431) [min] {1}
				child{
					node (c4314) [max] {4}
					child{
						node (c4314W) [max] {W}
					}
				}
			}
		child{
			node (c434) [min] {4}
			child{
				node (c4341) [max] {1}
				child{
					node (c4341T) [max] {T}
				}
			}
		}
		}
			child{
				node (c44) [max] {4}
				child{
					node (c44W) [max] {W}
				}
			}
		}
	}
	;
	\end{tikzpicture}
	\caption{Baumdiagramm zur Entscheidung auf 3 zu setzen}
	\end{figure}
	Im oberen Bereich des Baumdiagramms haben wir nun die Wahl des Feldes 3, die nächste Ebene ist minimierend. Auf der nächsten Ebene ist erneut alles maximierend und es tritt bei jeder Möglichkeit, durch einen schlauen Zug, ein Sieg für die KI ein. Der errechnete Wert ist dabei dann 3 ($Suchtiefe - aktuelle Suchtiefe$) und dieser Wert wird von keiner der anderen möglichen Felder übertroffen. \\\\
	Hier das weitere Spiel bis zum Sieg der KI (weiteres Log auch unter \code{/viergew/FachTex/}\\
	\code{maybe/fach3-4}):
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.4\linewidth, height=0.3\textheight]{maybe/fach4}
		\caption{KI gewinnt das Spiel}
		\label{fig:fach4}
	\end{figure}
	\subsection{Effizienzbetrachtung}
	Um mehr Züge zu simulieren, ist erheblich mehr Rechenleistung des Computers erforderlich. Die Komplexität steigt nahezu exponentiell, aber je weiter das Spiel fortgeschritten ist und je weniger Möglichkeiten es gibt, desto schneller wird der Algorithmus. Ich habe Simulationen mit verschiedenen Feldgrößen durchgeführt und den ersten Zug von der KI berechnen lassen. Dabei habe ich die Zeit gemessen und darauf basierend passende Suchtiefen gewählt, um die Zeit bei weniger als zehn Sekunden zu belassen. Hätte ich die vordefinierten Pfade genommen, wäre die Rechenzeit deutlich kürzer, jedoch bräuchte man zum Erstellen dieser sehr lange bzw. würde es den Rahmen dieser Facharbeit sprengen. Auch wäre es möglich anstatt der \code{VierLogik} Klasse einfach nur kopierte Arrays zu verwenden; aber dabei ist es schwer darauf zu achten, dass keines dieser Arrays verändert wird.\\
	Nun zur Effizienz bei verschiedenen Feldgrößen. Da die Höhe nicht so ausschlaggebend ist, wird hier nur betrachtet, wie sich die Ausführungszeit verändert, wenn die Suchtiefe und die Feldbreite variiert werden. Die KI versucht in jedem Fall den ersten Zug eines Spieles zu berechnen.\\
	Im Folgenden sind die Graphen der Ausführungszeit im Bezug auf die Suchtiefe dargestellt. Von oben nach unten mit den Feldbreiten 9, 7, 5. Es fällt deutlich auf, dass bis zu einer Suchtiefe von 5 kaum Unterschiede in der Rechenzeit auftreten. Von da an werden die Unterschiede pro weiterer Suchtiefe immer größer und steigen exponentiell. Der Wert für die Feldbreite 9 und Suchtiefe 9 fehlt, da ich die Messung nach 2 Stunden abgebrochen habe. Die Tests wurden durchgeführt mit der Klasse \code{Testing}.\\
		\begin{figure}[h]
			\centering
			\label{fig:graph1}
		\begin{tikzpicture}
		\begin{axis}[xlabel=Suchtiefe,ylabel=Rechenzeit in $s$]
		\addplot coordinates{%5
			(1,0.002)
			(2,0.001)
			(3,0.007)
			(4,0.027)
			(5,0.022)
			(6,0.122)
			(7,0.451)
			(8,2.104)
			(9,10.888)
		};
		\addplot coordinates{%7
			(1,0.0)
			(2,0.001)
			(3,0.003)
			(4,0.022)
			(5,0.164)
			(6,1.151)
			(7,8.182)
			(8,55.315)
			(9,389.38)
		};
		\addplot coordinates{%9
			(1,0.001)
			(2,0.001)
			(3,0.011)
			(4,0.099)
			(5,0.904)
			(6,8.096)
			(7,73.896)
			(8,653.781)
		};
		\legend{$5$,$7$,$9$}
		\end{axis}
		\end{tikzpicture}
		\caption{Relation Spielfeldbreite zu Ausführungszeit}
		\end{figure}
	\\\\\\\\\\\\Vielleicht wäre es auch eine Beschleunigung, wenn man keine Tiefensuche benutzt, sondern eine, die erst in die Breite sucht, da dort Siege oder Niederlagen für die aktuelle Ebene schon ausschlaggebend sein kann. Diese Idee ist mir leider erst später gekommen, aber dennoch werde ich diese Idee in dem Github Repository eventuell noch zu einem späteren Zeitpunkt umsetzen. Auch eine Abtrennung der Ergebnisberechnung könnten noch in einen anderen Thread verlagert werden, um das Einfrieren der grafischen Oberfläche zu verhindern. Auch ein Netzwerkspiel, wie bei dem Tic-Tac-Toe Spiel, wäre möglich, wobei dieses auch nicht ganz ausgereift ist.
	\section{Künstliche Intelligenz}
	Dieser Bereich behandelt die KI im Allgemeinen, sowie die gesellschaftlichen Aspekte, Ängste und Gefahren.
	\subsection{Definition}
	Das große Problem beim Begriff künstliche Intelligenz ist, dass es keine allgemeingültige Definition von Intelligenz gibt. Eine Möglichkeit ist es, Intelligenz als Fähigkeit Probleme zu lösen zu sehen. Darunter berücksichtigt wäre auch, dass es verschiedene Arten von Intelligenz gibt. So beschreibt es die \glqq Theorie der multiplen Intelligenzen\grqq{} von Howard Gardner. So habe jeder Mensch eine Mischung aus sieben Intelligenzarten.(Bulenda, Max \glqq Künstliche Intelligenz: Definition, Erklärung und Beispiele\grqq{}https://simplyki.de/kuenstliche-intelligenz-definition-erklaerung-und-beispiele/ Stand: 10.05.2019).
	Darauf achtend schauen wir uns den Wikipedia Artikel an, da dort meistens eine gesellschaftlich anerkannte Definition steht. \glqq Künstliche Intelligenz (KI, auch Artifizielle Intelligenz (AI bzw. A. I.), englisch artificial intelligence, AI) ist ein Teilgebiet der Informatik, welches sich mit der Automatisierung intelligenten Verhaltens und dem Maschinellen Lernen befasst.\grqq{} (Wikimedia Foundation Inc. \glqq Künstliche Intelligenz\grqq{} https://de.wikipedia.org/wiki/K\%C3\%BCnstliche\_Intelligenz Stand: 10.05.2019).
	Etwas ähnliches  ist auch im Gabler Wirtschaftslexikon zu finden: \glqq Erforschung intelligenten Problemlösungsverhaltens sowie die Erstellung intelligenter Computersysteme. Künstliche Intelligenz (KI) beschäftigt sich mit Methoden, die es einem Computer ermöglichen, solche Aufgaben zu lösen, die, wenn sie vom Menschen gelöst werden, Intelligenz erfordern.\grqq{} (Prof. Dr. Richard Lackes und Dr. Markus Siepermann \glqq Künstliche Intelligenz (KI)\grqq{} https://wirtschaftslexikon.gabler.de/definition/kuenstliche-intelligenz-ki-40285 Stand: 10.05.2019).
	Und auch bei Spektrum steht etwas ähnliches: \glqq Die künstliche Intelligenz (Abk. KI, \textit{E} artificial intelligence, Abk. AI) ist ein Teilgebiet der Informatik, welches sich mit der Erforschung von Mechanismen des intelligenten menschlichen Verhaltens befaßt (Intelligenz). Dieses geschieht durch Simulation mit Hilfe künstlicher Artefakte, gewöhnlich mit Computerprogrammen auf einer Rechenmaschine (Computersimulation).\grqq{} (Wichert, Andreas \glqq Künstliche Intelligenz\grqq{} https://www.spektrum.de/lexikon/neurowissenschaft/kuenstliche-intelligenz/6810 Stand: 10.05.2019).\\
	Dementsprechend kann man sagen, dass es sich wohl um die Nachahmung von menschlicher Intelligenz handelt, die durch Computersimulation oder andere Mechanismen erreicht wird.\\
	Damit lässt sich auch für einen Computergegner der Begriff künstliche Intelligenz wählen, da hier durch Computersimulation menschliche Intelligenz nachgeahmt wird.
	\subsection{Machine Learning}
	Ein Teilgebiet der künstlichen Intelligenz ist das Machine Learning, Maschinelles Lernen oder nur ML. Dabei geht es darum, aus vorhandenen Daten Muster und Gesetzmäßigkeiten abzuleiten, die dann bei ähnlichen Daten verwendet werden können. Solche lernenden Systeme können über verschiedene Wege angelernt werden, aber vor allem die Fortschritte im Bereich Big Data gaben diesem Themenfeld  eine enorme Bedeutung, da nun viele Daten zur Verfügung stehen, an denen gelernt werden kann (Luber, Stefan \glqq Was ist Machine Learning?\grqq{} https://www.bigdata-insider.de/was-ist-machine-learning-a-592092/ Stand:11.05.2019).
	\subsection{Aktueller Stand}
	Das heutige Leben wäre anders, wenn man auf künstliche Intelligenz verzichten würde. Das mag naheliegend sein bei Google Übersetzer oder anderer Sprachverarbeitung. Aber auch bei Verkehrsmitteln, wie Flugzeugen wird auf KI gesetzt. Man müsse also, um auf KI zu verzichten, mit einer Kutsche fahren (Kersting, Pia \glqq Künstliche Intelligenz (KI): Der aktuelle Stand der Technik\grqq{} https://lead-conduct.de/2017/11/21/kuenstliche-intelligenz-ki-der-aktuelle-stand-der-technik/ Stand:11.05.2019).
	Es sollte aber im Blick gehalten werden, dass KI unser Leben deutlich vereinfachen kann. So wurde schon 2018 bei der Google I/O demonstriert, wie es aussehen könnte, wenn der Google Assistant einen Termin für seinen Nutzer ausmacht (Engelien, Marco \glqq Googles Assistant kann bald euren Friseur anrufen und einen Termin machen\grqq{} https://curved.de/news/bei-anruf-google-der-assistant-macht-bald-termine-fuer-euch-ab-605280 Stand: 11.05.2019).
	Auch die Verfügbarkeit von Bibliotheken und Tutorials für KI oder ML ist hilfreich. So gibt es beispielsweise das von Google entwickelte open-source tensorflow Framework \footnote{https://github.com/tensorflow/tensorflow}, aber auch die Tutorials werden immer besser. Es gibt ein Spiel in dem man durch das Erlernen von ML gegen Außerirdische ankommen muss. Es befindet sich noch in der Alpha, ist aber ein guter Einstieg für python und ML, unter anderem mit verschiedenen python Bibliotheken, wie NumPy oder pandas.\footnote{https://ml-scifi.com}
	\subsection{Ausblick}
	Im Folgenden werde ich darauf eingehen, was in der Zukunft noch auf uns zukommen könnte bzw. was jetzt schon möglich ist. Ein gutes Beispiel für die Ängste der Menschen liefern Filme mit alternativen Welten, die unserer Welt ähneln. Als erstes Beispiel für eine lernende KI ist natürlich der Film \textit{Wargames} zu nennen. Darin erkennt die KI, dass Tic-Tac-Toe spielen immer nur im Unentschieden endet und überträgt dies auf einen thermonuklearen Krieg, in dem es auch keine Gewinner oder Verlierer gibt. Auch der Film \textit{I Robot} und die \textit{Terminator} Reihe spielen auf die große Angst der Menschen an, dass sich Maschinen gegen uns wenden werden. Auch im Film \textit{Matrix} scheint dies so zu sein, jedoch sollte hier auch die Vorgeschichte beachtet werden, in der die Menschen die Maschinen ablehnten. Es gibt auch andere Vertreter, in denen KI immer wieder auftaucht. In Spielen ist die Erzeugung von NPCs (nicht spielbarer Charakter) schon immer wichtig gewesen. Bei Brettspielen ist es eventuell noch möglich etwas zu simulieren, aber bei Shootern ist dies schon weniger möglich, so lassen manche Studios lieber die Mitstreiter verschwinden, als das sie eine wichtige Rolle im Kampf bekommen, weil sie sowieso nur im Weg stünden. Mit den jetzigen Möglichkeiten des ML könnten solche Dinge immer leichter umgangen werden.\\
	Ich denke im Allgemeinen entwickelt sich die KI zu unserem Nutzen. Auf die Gesetze der Robotik zurückgreifen wäre vielleicht eine Möglichkeit die Angst der Menschen zu mildern, aber es ist nur schwer abzuschätzen, ob KI uns irgendwann ersetzen wird oder nicht. Ob sie sich gegen uns auflehnen wird oder ob sie nur zu unserem Nutzen existieren wird ist ebenfalls fraglich. Die Gesetze der Robotik sind:\\
	\glqq1. Ein Roboter darf kein menschliches Wesen (wissentlich) verletzen oder durch Untätigkeit gestatten, dass einem menschlichen Wesen (wissentlich) Schaden zugefügt wird.\\
	2. Ein Roboter muss den ihm von einem Menschen gegebenen Befehlen gehorchen – es sei denn, ein solcher Befehl würde mit Regel eins kollidieren.\\
	3. Ein Roboter muss seine Existenz beschützen, solange dieser Schutz nicht mit Regel eins oder zwei kollidiert.\grqq{}\\
	(Asimov, Isaac \glqq Runaround\grqq{} https://deacademic.com/dic.nsf/dewiki/518180)\\\\
	Diese Gesetze prägten maßgeblich das Bild von Robotern die selbstständig denken und sind, wie ich finde eine gute Grundlage, falls Roboter mal einen größeren Prozentsatz der Welt darstellen. Sie ermöglichen friedliches Zusammenleben.\\\\
	Sobald Quantencomputer und KI miteinander verbunden werden, muss sicherlich nochmal intensiver über die Gefahren und Nutzen nachgedacht und abgewägt werden.
	\newpage
	\section{Fazit}
	Am Ende der Facharbeit möchte ich noch einmal erwähnen, dass es immer eine Bereicherung ist mit \LaTeX{}\footnote{https://www.latex-project.org/} einen Text zu schreiben und ich den Erfindern sehr dafür danke. Es ist immer wieder eindrucksvoll, was mit \LaTeX{} alles möglich ist, wie die Baumdiagramme und der Graph. Die Klassendiagramme wurden erstellt mit dem Programm \glqq Umbrello\grqq{}\footnote{https://umbrello.kde.org/}. Des Weiteren habe ich nach dem komplette Entwicklungsprozess noch \textit{javadoc} erstellt. Die Dokumentation ist genauso wie der Quellcode und die Kommentare in Englisch gehalten, da dies auch bei deutschen Software Unternehmen so gehandhabt wird und jeder Quelltext, der auf Github ist auch für eine möglichst große Anzahl an Personen zur Verfügung stehen sollte. Die dokumentation ist zu finden unter \code{/viergew/doc/}. Ich denke das faszinierende am Programmieren ist das Experimentieren und das niemals endgültig fertig sein mit etwas. Dieses Projekt hat mir außerdem noch einmal gezeigt, wie wichtig Tests sind. So fiel mir ein gravierender Fehler in der KI erst auf, als meine Schwester das Programm testete. Die KI dachte, dass sie weniger Felder zur Verfügung habe und nutzte nicht alle Möglichkeiten.\\
	Ich denke KI ist eine große Möglichkeit für die Weiterentwicklung der Menschheit und ich werde mich auch noch weiterhin damit beschäftigen, da dieser Bereich in den letzten Jahren ziemlich zugelegt hat und auch noch wachsen wird.
	\newpage
	\section{Quellen-/ Literaturverzeichnis}
	Bulenda, Max \glqq Künstliche Intelligenz: Definition, Erklärung und Beispiele\grqq{}\\ https://simplyki.de/kuenstliche-intelligenz-definition-erklaerung-und-beispiele/\\\\
	Kersting, Pia \glqq Künstliche Intelligenz (KI): Der aktuelle Stand der Technik\grqq{}\\ https://lead-conduct.de/2017/11/21/kuenstliche-intelligenz-ki-der-aktuelle-stand-der-technik/\\\\
	Lehmann, Jörg \glqq Vier gewinnt\grqq{} http://www.brettspiele-report.de/vier-gewinnt/\\\\
	Luber, Stefan \glqq Was ist Machine Learning?\grqq{} \\https://www.bigdata-insider.de/was-ist-machine-learning-a-592092/\\\\
	Prof. Dr. Richard Lackes und Dr. Markus Siepermann\glqq Künstliche Intelligenz (KI)\grqq{}\\ https://wirtschaftslexikon.gabler.de/definition/kuenstliche-intelligenz-ki-40285\\\\
	Tromp, John  \glqq John's Connect Four Playground \grqq{}\\ http://tromp.github.io/c4/c4.html\\\\
	Wichert, Andreas \glqq Künstliche Intelligenz\grqq{}\\ https://www.spektrum.de/lexikon/neurowissenschaft/kuenstliche-intelligenz/6810\\\\
	Wikimedia Foundation Inc. \glqq Künstliche Intelligenz\grqq{}\\ https://de.wikipedia.org/wiki/K\%C3\%BCnstliche\_Intelligenz\\\\
	Wikimedia Foundation Inc. \glqq Minimax\grqq{} https://en.wikipedia.org/wiki/Minimax\\
	\section{Bilderverzeichnis}
	Bild oben links auf der Titelseite: Logo der Schule\\
	Bild mittig auf der Titelseite: selbst gemachtes Foto\\
	Abbildung 1: Implementationsdiagramme von \glqq Umbrello\grqq{} erstellt\\
	Abbildung 2: Screenshot der Tabelle von  Tromp, John  \glqq John's Connect Four Playground \grqq{}\\
	Abbildung 3: Implementationsdiagramm von \glqq Umbrello\grqq{} erstellt\\
	Abbildung 4, 5, 7, 8, 10: Screenshots aus dem Programm\\
	Abbildung 6, 9: Eigens erstellte Baumdiagramme\\
	Abbildung 11: Eigens erstellter Graph\\
	\section{Selbstständigkeitserklärung}
	Ich erkläre, dass ich die Facharbeit ohne fremde Hilfe angefertigt und nur die
	im Literaturverzeichnis angeführten Quellen und Hilfsmittel benutzt habe.
	Insbesondere versichere ich, dass ich alle wörtlichen und sinngemäßen
	Übernahmen aus anderen Werken als solche kenntlich gemacht habe.
	\\\\
	Raesfeld, 14.05.2019
	\\\\\\
	\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
\end{document}

